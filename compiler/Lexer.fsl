//This lexer has been writen with help of "Real world OCaml" book By Yaron Minsky, Anil Madhavapeddy, Jason Hickey (chapter 15)
{
open FSharp.Text.Lexing
open System
open Parser

exception SyntaxError of string

let lexeme = LexBuffer<_>.LexemeString

let newline (lexbuf: LexBuffer<_>) = 
  lexbuf.StartPos <- lexbuf.StartPos.NextLine
}

let letter = ['a' - 'z']
let digit = ['0' - '9']
let operator = ['(' ')' '+' '-' '/' '*' '%' '=']
let whitespace = [' ' '\t']
let newline = '\r' | '\n' | "\r\n"

// rule read =
//   parse
//   | "for"         { Command <| lexeme lexbuf }
//   | "print"       { Command <| lexeme lexbuf }
//   | "let"         { Command <| lexeme lexbuf }
//   | "if"          { Command <| lexeme lexbuf }
//   | "then"        { Command <| lexeme lexbuf }
//   | "do"          { Command <| lexeme lexbuf }
//   | "begin"       { Command <| lexeme lexbuf }
//   | "end"         { Command <| lexeme lexbuf }
//   | letter        { Identifier <| lexeme lexbuf }
//   | digit+        { Constant (int ((lexeme lexbuf))) }
//   | operator      { Operator <| lexbuf.LexemeChar 0 }
//   | newline       { printfn "%d" lexbuf.StartPos.Line; newline lexbuf; read lexbuf }
//   | whitespace+   { read lexbuf }
//   | eof           { EOF }
//   | _   { raise (Exception (sprintf "SyntaxError: Unexpected char: '%s' Line: %d Column: %d" (lexeme lexbuf) (lexbuf.StartPos.Line+1) lexbuf.StartPos.Column))}

rule read =
  parse
  | "print"       { T_print }
  | digit+        { T_int (int (lexeme lexbuf)) }
  | newline       { newline lexbuf; read lexbuf }
  | whitespace+   { read lexbuf }
  | eof           { EOF }
  | _   { raise (Exception (sprintf "SyntaxError: Unexpected char: '%s' Line: %d Column: %d" (lexeme lexbuf) (lexbuf.StartPos.Line+1) lexbuf.StartPos.Column))}


//   | white    { read lexbuf }
//   | newline  { newline lexbuf; read lexbuf }
//   | int      { INT (int (lexeme lexbuf)) }
//   | float    { FLOAT (float (lexeme lexbuf)) }
//   | "true"   { TRUE }
//   | "false"  { FALSE }
//   | "null"   { NULL }
//   | '"'      { read_string "" false lexbuf } 
//   | '{'      { LEFT_BRACE }
//   | '}'      { RIGHT_BRACE }
//   | '['      { LEFT_BRACK }
//   | ']'      { RIGHT_BRACK }
//   | ':'      { COLON }
//   | ','      { COMMA }
//   | eof      { EOF }
//   | _ { raise (Exception (sprintf "SyntaxError: Unexpected char: '%s' Line: %d Column: %d" (lexeme lexbuf) (lexbuf.StartPos.Line+1) lexbuf.StartPos.Column)) }


// and read_string str ignorequote =
//   parse
//   | '"'           { if ignorequote  then (read_string (str+"\\\"") false lexbuf) else STRING (str) }
//   | '\\'          { read_string str true lexbuf }
//   | [^ '"' '\\']+ { read_string (str+(lexeme lexbuf)) false lexbuf }
//   | eof           { raise (Exception ("String is not terminated")) }