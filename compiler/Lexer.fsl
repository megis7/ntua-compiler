{
open FSharp.Text.Lexing
open System
open Parser
open Compiler.PCL

exception LexerError of string

let lexeme = LexBuffer<_>.LexemeString

let newline (lexbuf: LexBuffer<_>) =
  lexbuf.EndPos <- lexbuf.EndPos.NextLine

let errorStr (msg: string) (lexbuf: LexBuffer<_>) =
  sprintf "(line %d: char %d..%d): %s" (lexbuf.StartPos.Line + 1) (lexbuf.StartPos.Column + 1) (lexbuf.EndPos.Column) msg

let lexError (lexbuf: LexBuffer<_>) = 
  raise <| LexerError ( errorStr (lexeme lexbuf) lexbuf )

 // TODO: Check that character has unit length
}

let letter = ['a' - 'z']
let digit = ['0' - '9']
let operator = ['(' ')' '+' '-' '/' '*' '%' '=']
let whitespace = [' ' '\t']
let newline = '\r' | '\n' | "\r\n"

let integer = digit*

let fractional = '.' digit+
let exp = ['e' 'E'] ['+' '-']? digit+
let real = integer fractional? exp?

let identifier = ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*

let escapes = ['n' 't' 'r' '0' '\\' '\'' '"']

rule read =
  parse
  | "integer"     { K_basicType (Integer) }
  | "boolean"     { K_basicType (Boolean) }
  | "char"        { K_basicType (Character) }
  | "real"        { K_basicType (Real) }

  | "array"       { K_array }
  | "of"          { K_of }

  | "program"     { K_program }
  | "begin"       { K_begin }
  | "end"         { K_end }
  | "procedure"   { K_procedure }
  | "function"    { K_function }
  | "forward"     { K_forward }
  | "result"      { K_result }

  | "true"        { K_true }
  | "false"       { K_false }
  | "nil"         { K_nil }

  | "var"         { K_var }

  | ":="          { O_assign }
  | "@"           { O_addr }
  | "not"         { O_not }
  | "+"           { O_plus }
  | "-"           { O_minus }
  | "*"           { O_mult }
  | "/"           { O_div }
  | "div"         { O_divi }
  | "mod"         { O_mod }
  | "or"          { O_or }
  | "and"         { O_and }
  | "="           { O_equals }
  | "<>"          { O_nequals }
  | "<"           { O_less }
  | "<="          { O_leq }
  | ">"           { O_greater }
  | ">="          { O_geq }

  | ";"           { Semicolon }
  | ":"           { Colon }
  | ","           { Comma }
  | "["           { Lbrack }
  | "]"           { Rbrack }
  | "^"           { Carret }
  | "."           { Dot }
  | "("           { Lparen }
  | ")"           { Rparen }

  | identifier    { T_id (lexeme lexbuf) }
  | integer       { T_int (int <| lexeme lexbuf) }
  | real          { T_real (lexeme lexbuf) }
  | '"'           { T_str (readString "" lexbuf + "\x00") }
  | '\''          { T_char (readChar "" lexbuf) }
  | "(*"          { consumeComment lexbuf |> ignore; read lexbuf }
  | newline       { newline lexbuf; read lexbuf }
  | whitespace+   { read lexbuf }
  | eof           { EOF }
  | _             { lexError lexbuf }

and readString str =
  parse
  | '"'                   { str }
  | '\\'                  { readString (str + readEscape "\\" lexbuf) lexbuf }
  | [^'"' '\\' '\n']+     { readString (str + (lexeme lexbuf)) lexbuf }
  | eof | '\n'            { raise (Exception ("String not terminated at " + sprintf "Line: %d Column: %d" (lexbuf.StartPos.Line + 1) lexbuf.StartPos.Column)) }

// TODO: Parse error when ''
and readChar str =
  parse
  | '\''                  { str }
  | '\\'                  { readChar (str + readEscape "\\" lexbuf) lexbuf }
  | _                     { readChar (str + lexeme lexbuf) lexbuf }
  | eof                   { raise (Exception ("Character not terminated")) }

and readEscape str =
  parse
  | escapes     { str + lexeme lexbuf }
  | _           { raise (Exception ("Bad escape sequence")) }

and consumeComment =
  parse
  | "*)"        { }
  | "\n"        { newline lexbuf; consumeComment lexbuf }
  | _           { consumeComment lexbuf }
  | eof         { raise (Exception ("Comment not terminated")) }