{
open System
open FSharp.Text.Lexing
open Compiler.Helpers
open Compiler.Helpers.Error.Lexer
open Compiler.Base
open Parser

let lexeme = LexBuffer<_>.LexemeString

let private newline (lexbuf: LexBuffer<_>) =
  lexbuf.EndPos <- lexbuf.EndPos.NextLine

let private errorStr (msg: string) (lexbuf: LexBuffer<_>) =
  sprintf "%s %s" (Error.FormatPrologue lexbuf.StartPos) msg

let private beautifyErroneousToken (tok: string) =
  match tok with
  | "\n" -> "<EOL>"
  | "\t" -> "<TAB>"
  | _    -> tok

let private lexError (msg: string) (lexbuf: LexBuffer<_>) = 
  raise <| LexerException (errorStr (sprintf "%s. Erroneous token '%s'." msg (beautifyErroneousToken <| lexeme lexbuf)) lexbuf)

}

let letter = ['a' - 'z']
let digit = ['0' - '9']
let operator = ['(' ')' '+' '-' '/' '*' '%' '=']
let whitespace = [' ' '\t']
let newline = '\r' | '\n' | "\r\n"

let integer = digit*

let fractional = '.' digit+
let exp = ['e' 'E'] ['+' '-']? digit+
let real = integer fractional? exp?

let identifier = ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9' '_']*

let escapes = ['n' 't' 'r' '0' '\\' '\'' '"']

rule read =
  parse
  | "integer"     { K_basicType (Integer) }
  | "boolean"     { K_basicType (Boolean) }
  | "char"        { K_basicType (Character) }
  | "real"        { K_basicType (Real) }

  | "array"       { K_array }
  | "of"          { K_of }

  | "program"     { K_program }
  | "begin"       { K_begin }
  | "end"         { K_end }
  | "procedure"   { K_procedure }
  | "function"    { K_function }
  | "forward"     { K_forward }
  | "result"      { K_result }

  | "true"        { K_true }
  | "false"       { K_false }
  | "nil"         { K_nil }

  | "var"         { K_var }

  | ":="          { O_assign }
  | "@"           { O_addr }
  | "not"         { O_not }
  | "+"           { O_plus }
  | "-"           { O_minus }
  | "*"           { O_mult }
  | "/"           { O_div }
  | "div"         { O_divi }
  | "mod"         { O_mod }
  | "or"          { O_or }
  | "and"         { O_and }
  | "="           { O_equals }
  | "<>"          { O_nequals }
  | "<"           { O_less }
  | "<="          { O_leq }
  | ">"           { O_greater }
  | ">="          { O_geq }

  | ";"           { Semicolon }
  | ":"           { Colon }
  | ","           { Comma }
  | "["           { Lbrack }
  | "]"           { Rbrack }
  | "^"           { Carret }
  | "."           { Dot }
  | "("           { Lparen }
  | ")"           { Rparen }

  | identifier    { T_id (lexeme lexbuf) }
  | integer       { T_int (int <| lexeme lexbuf) }
  | real          { T_real (lexeme lexbuf) }
  | '"'           { T_str (readString "" lexbuf + "\x00") }
  | '\''          { T_char (readChar "" lexbuf) }
  | "(*"          { consumeComment lexbuf |> ignore; read lexbuf }
  | newline       { newline lexbuf; read lexbuf }
  | whitespace+   { read lexbuf }
  | eof           { EOF }
  | _             { lexError "Unexpected character" lexbuf }

and readString str =
  parse
  | '"'                   { str }
  | '\\'                  { readString (str + readEscape "\\" lexbuf) lexbuf }
  | [^'"' '\\' '\n']+     { readString (str + (lexeme lexbuf)) lexbuf }
  | eof | '\n'            { lexError "String stream not terminated" lexbuf }

and readChar str =
  parse
  | '\''                  { if checkCharacter str = false then lexError "Expected single character but found multi-character stream" lexbuf else str }
  | '\\'                  { readChar (str + readEscape "\\" lexbuf) lexbuf }
  | eof | '\n'            { lexError "Character stream not terminated" lexbuf }
  | _                     { readChar (str + lexeme lexbuf) lexbuf }

and readEscape str =
  parse
  | escapes     { str + lexeme lexbuf }
  | _           { lexError "Bad escape sequence" lexbuf }

and consumeComment =
  parse
  | "*)"        { }
  | "\n"        { newline lexbuf; consumeComment lexbuf }
  | _           { consumeComment lexbuf }
  | eof         { lexError "Comment stream not terminated" lexbuf }